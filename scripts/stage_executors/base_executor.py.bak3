"""
éšŽæ®µåŸ·è¡Œå™¨åŸºé¡ž

æä¾›çµ±ä¸€çš„åŸ·è¡Œæµç¨‹ï¼Œæ¸›å°‘é‡è¤‡ä»£ç¢¼ã€‚
å­é¡žåªéœ€å¯¦ç¾é…ç½®åŠ è¼‰å’Œè™•ç†å™¨å‰µå»ºé‚è¼¯ã€‚

Author: Orbit Engine Refactoring Team
Date: 2025-10-12
Version: 1.0
"""

from abc import ABC, abstractmethod
from pathlib import Path
from typing import Optional, Tuple, Dict, Any
import json
import logging

# å°Žå…¥å·¥å…·å‡½æ•¸
from .executor_utils import (
    clean_stage_outputs,
    find_latest_stage_output,
    project_root
)

# å°Žå…¥è™•ç†çµæžœé¡žåž‹
from src.shared.base import ProcessingStatus


class StageExecutor(ABC):
    """
    éšŽæ®µåŸ·è¡Œå™¨åŸºé¡ž - çµ±ä¸€åŸ·è¡Œæµç¨‹

    ä½¿ç”¨ Template Method Patternï¼Œå®šç¾©æ¨™æº–åŸ·è¡Œæµç¨‹ï¼š
    1. é¡¯ç¤ºéšŽæ®µé ­éƒ¨
    2. æ¸…ç†èˆŠè¼¸å‡º
    3. è¼‰å…¥å‰éšŽæ®µæ•¸æ“šï¼ˆå¦‚éœ€è¦ï¼‰
    4. è¼‰å…¥é…ç½®ï¼ˆå­é¡žå¯¦ç¾ï¼‰
    5. å‰µå»ºè™•ç†å™¨ï¼ˆå­é¡žå¯¦ç¾ï¼‰
    6. åŸ·è¡Œè™•ç†
    7. ä¿å­˜é©—è­‰å¿«ç…§
    8. éŒ¯èª¤è™•ç†

    å­é¡žåªéœ€å¯¦ç¾:
    - load_config(): è¼‰å…¥éšŽæ®µé…ç½®
    - create_processor(): å‰µå»ºè™•ç†å™¨å¯¦ä¾‹
    - requires_previous_stage(): æ˜¯å¦éœ€è¦å‰éšŽæ®µæ•¸æ“šï¼ˆå¯é¸ï¼‰
    """

    def __init__(self, stage_number: int, stage_name: str, emoji: str = "ðŸ“¦"):
        """
        åˆå§‹åŒ–åŸ·è¡Œå™¨

        Args:
            stage_number: éšŽæ®µç·¨è™Ÿ (1-6)
            stage_name: éšŽæ®µåç¨±ï¼ˆä¸­æ–‡ï¼‰
            emoji: éšŽæ®µåœ–æ¨™ï¼ˆå¯é¸ï¼Œé»˜èª ðŸ“¦ï¼‰
        """
        self.stage_number = stage_number
        self.stage_name = stage_name
        self.emoji = emoji
        self.logger = logging.getLogger(f"stage{stage_number}_executor")

    def execute(self, previous_results: Optional[Dict] = None) -> Tuple[bool, Any, Any]:
        """
        åŸ·è¡ŒéšŽæ®µè™•ç†ï¼ˆæ¨¡æ¿æ–¹æ³•ï¼‰

        é€™æ˜¯æ ¸å¿ƒåŸ·è¡Œæµç¨‹ï¼Œå­é¡žä¸æ‡‰è¦†è“‹æ­¤æ–¹æ³•ã€‚
        å­é¡žæ‡‰å¯¦ç¾ load_config() å’Œ create_processor()ã€‚

        Args:
            previous_results: å‰åºéšŽæ®µçµæžœå­—å…¸ï¼ˆå¯é¸ï¼‰

        Returns:
            tuple: (success: bool, result: ProcessingResult, processor: Processor)
                - success: æ˜¯å¦åŸ·è¡ŒæˆåŠŸ
                - result: è™•ç†çµæžœå°è±¡ï¼ˆæˆ– Noneï¼‰
                - processor: è™•ç†å™¨å¯¦ä¾‹ï¼ˆæˆ– Noneï¼‰
        """
        try:
            # Step 1: é¡¯ç¤ºéšŽæ®µé ­éƒ¨
            self._print_stage_header()

            # Step 2: æ¸…ç†èˆŠè¼¸å‡º
            clean_stage_outputs(self.stage_number)

            # Step 3: è¼‰å…¥å‰éšŽæ®µæ•¸æ“šï¼ˆå¦‚éœ€è¦ï¼‰
            input_data = None
            if self.requires_previous_stage():
                input_data = self._load_previous_stage_data()
                if input_data is None:
                    # å‰éšŽæ®µæ•¸æ“šç¼ºå¤±ï¼Œç„¡æ³•ç¹¼çºŒ
                    return False, None, None

            # Step 4: è¼‰å…¥é…ç½®ï¼ˆå­é¡žå¯¦ç¾ï¼‰
            config = self.load_config()

            # Step 5: é¡¯ç¤ºé…ç½®æ‘˜è¦ï¼ˆå¯é¸ï¼‰
            self._print_config_summary(config)

            # Step 6: å‰µå»ºè™•ç†å™¨ï¼ˆå­é¡žå¯¦ç¾ï¼‰
            processor = self.create_processor(config)

            # Step 7: åŸ·è¡Œè™•ç†ï¼ˆçµ±ä¸€æŽ¥å£ï¼‰
            result = processor.execute(input_data)

            # Step 8: æª¢æŸ¥çµæžœ
            if not self._check_result(result):
                return False, result, processor

            # Step 9: é¡¯ç¤ºè™•ç†çµæžœæ‘˜è¦
            self._print_result_summary(result)

            # Step 10: ä¿å­˜é©—è­‰å¿«ç…§ï¼ˆå¦‚æžœè™•ç†å™¨æ”¯æŒï¼‰
            self._save_validation_snapshot(processor, result)

            return True, result, processor

        except Exception as e:
            # çµ±ä¸€éŒ¯èª¤è™•ç†
            error_msg = f'âŒ Stage {self.stage_number} åŸ·è¡Œç•°å¸¸: {e}'
            self.logger.error(error_msg, exc_info=True)
            print(error_msg)
            return False, None, None

    # ===== å­é¡žå¿…é ˆå¯¦ç¾çš„æŠ½è±¡æ–¹æ³• =====

    @abstractmethod
    def load_config(self) -> Dict[str, Any]:
        """
        è¼‰å…¥éšŽæ®µé…ç½®

        å­é¡žå¿…é ˆå¯¦ç¾æ­¤æ–¹æ³•ï¼Œå¾ž YAML æ–‡ä»¶æˆ–å…¶ä»–ä¾†æºè¼‰å…¥é…ç½®ã€‚

        Returns:
            Dict[str, Any]: é…ç½®å­—å…¸

        Example:
            ```python
            def load_config(self) -> Dict[str, Any]:
                config_path = project_root / "config/stage1_orbital_calculation.yaml"
                with open(config_path, 'r') as f:
                    return yaml.safe_load(f)
            ```
        """
        pass

    @abstractmethod
    def create_processor(self, config: Dict[str, Any]) -> Any:
        """
        å‰µå»ºè™•ç†å™¨å¯¦ä¾‹

        å­é¡žå¿…é ˆå¯¦ç¾æ­¤æ–¹æ³•ï¼Œæ ¹æ“šé…ç½®å‰µå»ºå°æ‡‰çš„è™•ç†å™¨ã€‚

        Args:
            config: load_config() è¿”å›žçš„é…ç½®å­—å…¸

        Returns:
            è™•ç†å™¨å¯¦ä¾‹ï¼ˆç¹¼æ‰¿è‡ª BaseStageProcessorï¼‰

        Example:
            ```python
            def create_processor(self, config):
                from stages.stage1_orbital_calculation.stage1_main_processor import create_stage1_processor
                return create_stage1_processor(config)
            ```
        """
        pass

    # ===== å­é¡žå¯è¦†è“‹çš„å¯é¸æ–¹æ³• =====

    def requires_previous_stage(self) -> bool:
        """
        æ˜¯å¦éœ€è¦å‰éšŽæ®µæ•¸æ“š

        é»˜èªè¡Œç‚ºï¼šStage 1 ä¸éœ€è¦ï¼Œå…¶ä»–éšŽæ®µéœ€è¦ã€‚
        å­é¡žå¯ä»¥è¦†è“‹æ­¤æ–¹æ³•è‡ªå®šç¾©è¡Œç‚ºã€‚

        Returns:
            bool: True å¦‚æžœéœ€è¦å‰éšŽæ®µæ•¸æ“š
        """
        return self.stage_number > 1

    def get_previous_stage_number(self) -> int:
        """
        ç²å–å‰éšŽæ®µç·¨è™Ÿ

        é»˜èªè¡Œç‚ºï¼šç•¶å‰éšŽæ®µ - 1
        å­é¡žå¯ä»¥è¦†è“‹æ­¤æ–¹æ³•ï¼ˆä¾‹å¦‚è·³éšŽæ®µåŸ·è¡Œï¼‰ã€‚

        Returns:
            int: å‰éšŽæ®µç·¨è™Ÿ
        """
        return self.stage_number - 1

    # ===== å…§éƒ¨è¼”åŠ©æ–¹æ³•ï¼ˆåŸºé¡žå¯¦ç¾ï¼Œå­é¡žä¸æ‡‰è¦†è“‹ï¼‰ =====

    def _print_stage_header(self):
        """é¡¯ç¤ºéšŽæ®µé ­éƒ¨ä¿¡æ¯"""
        print(f'\n{self.emoji} éšŽæ®µ{self.stage_number}ï¼š{self.stage_name}')
        print('-' * 60)

    def _load_previous_stage_data(self) -> Optional[Dict]:
        """
        è¼‰å…¥å‰éšŽæ®µæ•¸æ“š

        Returns:
            Optional[Dict]: å‰éšŽæ®µæ•¸æ“šï¼Œå¦‚æžœæ‰¾ä¸åˆ°å‰‡è¿”å›ž None
        """
        previous_stage = self.get_previous_stage_number()
        output_file = find_latest_stage_output(previous_stage)

        if not output_file:
            error_msg = f'âŒ æ‰¾ä¸åˆ° Stage {previous_stage} è¼¸å‡ºæ–‡ä»¶ï¼Œè«‹å…ˆåŸ·è¡Œ Stage {previous_stage}'
            self.logger.error(error_msg)
            print(error_msg)
            return None

        try:
            with open(output_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
            self.logger.info(f"âœ… å·²è¼‰å…¥ Stage {previous_stage} æ•¸æ“š: {output_file}")
            return data
        except Exception as e:
            error_msg = f'âŒ è¼‰å…¥ Stage {previous_stage} æ•¸æ“šå¤±æ•—: {e}'
            self.logger.error(error_msg)
            print(error_msg)
            return None

    def _check_result(self, result) -> bool:
        """
        æª¢æŸ¥è™•ç†çµæžœ

        Args:
            result: è™•ç†å™¨è¿”å›žçš„çµæžœ

        Returns:
            bool: True å¦‚æžœçµæžœæœ‰æ•ˆ
        """
        if not result:
            error_msg = f'âŒ Stage {self.stage_number} ç„¡è¿”å›žçµæžœ'
            self.logger.error(error_msg)
            print(error_msg)
            return False

        # èª¿è©¦ï¼šé¡¯ç¤º result çš„é¡žåž‹å’Œç‹€æ…‹
        self.logger.debug(f"ðŸ” Result type: {type(result)}")
        self.logger.debug(f"ðŸ” Has status: {hasattr(result, 'status')}")
        if hasattr(result, 'status'):
            self.logger.debug(f"ðŸ” Status value: {result.status}")
            self.logger.debug(f"ðŸ” Status type: {type(result.status)}")
            self.logger.debug(f"ðŸ” ProcessingStatus.SUCCESS: {ProcessingStatus.SUCCESS}")
            self.logger.debug(f"ðŸ” Comparison: {result.status == ProcessingStatus.SUCCESS}")

        # æª¢æŸ¥ç‹€æ…‹
        if hasattr(result, 'status'):
            # æ”¯æŒæžšèˆ‰å’Œå­—ç¬¦ä¸²æ¯”è¼ƒï¼ˆå‘å¾Œå…¼å®¹ï¼‰
            is_success = (result.status == ProcessingStatus.SUCCESS or
                         result.status == ProcessingStatus.COMPLETED or
                         (hasattr(result.status, 'value') and result.status.value == 'success'))

            if not is_success:
                errors = '; '.join(result.errors) if hasattr(result, 'errors') and result.errors else "æœªçŸ¥éŒ¯èª¤"
                error_msg = f'âŒ Stage {self.stage_number} åŸ·è¡Œå¤±æ•—: {errors}'
                self.logger.error(error_msg)
                print(error_msg)
                return False

        # æª¢æŸ¥æ•¸æ“š
        if hasattr(result, 'data') and not result.data:
            error_msg = f'âŒ Stage {self.stage_number} è¿”å›žæ•¸æ“šç‚ºç©º'
            self.logger.error(error_msg)
            print(error_msg)
            return False

        return True

    def _save_validation_snapshot(self, processor, result):
        """
        ä¿å­˜é©—è­‰å¿«ç…§

        Args:
            processor: è™•ç†å™¨å¯¦ä¾‹
            result: è™•ç†çµæžœ
        """
        if not hasattr(processor, 'save_validation_snapshot'):
            # è™•ç†å™¨ä¸æ”¯æŒå¿«ç…§ä¿å­˜ï¼Œè·³éŽ
            return

        try:
            # æå–æ•¸æ“šï¼ˆè™•ç† ProcessingResult å°è±¡ï¼‰
            data = result.data if hasattr(result, 'data') else result

            # èª¿ç”¨è™•ç†å™¨çš„å¿«ç…§ä¿å­˜æ–¹æ³•
            snapshot_saved = processor.save_validation_snapshot(data)

            if snapshot_saved:
                self.logger.info(f'âœ… Stage {self.stage_number} é©—è­‰å¿«ç…§å·²ä¿å­˜')
                print(f'âœ… Stage {self.stage_number} é©—è­‰å¿«ç…§å·²ä¿å­˜')
            else:
                self.logger.warning(f'âš ï¸ Stage {self.stage_number} é©—è­‰å¿«ç…§ä¿å­˜å¤±æ•—')
                print(f'âš ï¸ Stage {self.stage_number} é©—è­‰å¿«ç…§ä¿å­˜å¤±æ•—')

        except Exception as e:
            # å¿«ç…§ä¿å­˜å¤±æ•—ä¸æ‡‰ä¸­æ–·ä¸»æµç¨‹ï¼Œåªè¨˜éŒ„è­¦å‘Š
            warning_msg = f'âš ï¸ Stage {self.stage_number} é©—è­‰å¿«ç…§ä¿å­˜å¤±æ•—: {e}'
            self.logger.warning(warning_msg)
            print(warning_msg)

    def _print_config_summary(self, config: Dict[str, Any]):
        """
        é¡¯ç¤ºé…ç½®æ‘˜è¦ï¼ˆå¯é¸ï¼Œç”±å­é¡žæ±ºå®šæ˜¯å¦èª¿ç”¨ï¼‰

        Args:
            config: é…ç½®å­—å…¸
        """
        # åŸºé¡žä¸é¡¯ç¤ºï¼Œå­é¡žå¯ä»¥è¦†è“‹æ­¤æ–¹æ³•æ·»åŠ è‡ªå®šç¾©æ‘˜è¦
        pass

    def _print_result_summary(self, result):
        """
        é¡¯ç¤ºè™•ç†çµæžœæ‘˜è¦

        Args:
            result: è™•ç†çµæžœ
        """
        if not hasattr(result, 'data') or not hasattr(result, 'metrics'):
            return

        data = result.data
        metrics = result.metrics

        # é¡¯ç¤ºé€šç”¨çµ±è¨ˆä¿¡æ¯
        print(f'ðŸ“Š è™•ç†ç‹€æ…‹: {result.status.value if hasattr(result, "status") else "æœªçŸ¥"}')

        if hasattr(metrics, 'duration_seconds'):
            print(f'ðŸ“Š è™•ç†æ™‚é–“: {metrics.duration_seconds:.3f}ç§’')

        # é¡¯ç¤ºéšŽæ®µç‰¹å®šçš„çµ±è¨ˆï¼ˆå¦‚æžœæœ‰ï¼‰
        if isinstance(data, dict):
            # Stage 1: è¡›æ˜Ÿæ•¸é‡
            if 'satellites' in data:
                print(f'ðŸ“Š è™•ç†è¡›æ˜Ÿ: {len(data["satellites"])}é¡†')

            # Stage 2: æ™‚é–“åºåˆ—é•·åº¦
            if 'metadata' in data and 'time_series_length' in data['metadata']:
                print(f'ðŸ“Š æ™‚é–“åºåˆ—: {data["metadata"]["time_series_length"]}é»ž')

            # Stage 4: å¯è¦‹è¡›æ˜Ÿæ•¸é‡
            if 'link_feasibility' in data:
                print(f'ðŸ“Š å¯è¦‹è¡›æ˜Ÿ: {len(data["link_feasibility"])}é¡†')

            # Stage 5: ä¿¡è™Ÿåˆ†æžè¡›æ˜Ÿæ•¸é‡
            if 'signal_analysis' in data:
                print(f'ðŸ“Š åˆ†æžè¡›æ˜Ÿ: {len(data["signal_analysis"])}é¡†')

            # Stage 6: äº‹ä»¶æ•¸é‡
            if 'handover_events' in data:
                print(f'ðŸ“Š æ›æ‰‹äº‹ä»¶: {len(data["handover_events"])}å€‹')


# ===== ä¾¿æ·å‡½æ•¸ï¼ˆå‘å¾Œå…¼å®¹ï¼‰ =====

def create_stage_executor(stage_number: int, executor_class) -> StageExecutor:
    """
    å‰µå»ºéšŽæ®µåŸ·è¡Œå™¨çš„å·¥å» å‡½æ•¸

    Args:
        stage_number: éšŽæ®µç·¨è™Ÿ
        executor_class: åŸ·è¡Œå™¨é¡ž

    Returns:
        StageExecutor: åŸ·è¡Œå™¨å¯¦ä¾‹
    """
    return executor_class()
