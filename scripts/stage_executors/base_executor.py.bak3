"""
階段執行器基類

提供統一的執行流程，減少重複代碼。
子類只需實現配置加載和處理器創建邏輯。

Author: Orbit Engine Refactoring Team
Date: 2025-10-12
Version: 1.0
"""

from abc import ABC, abstractmethod
from pathlib import Path
from typing import Optional, Tuple, Dict, Any
import json
import logging

# 導入工具函數
from .executor_utils import (
    clean_stage_outputs,
    find_latest_stage_output,
    project_root
)

# 導入處理結果類型
from src.shared.base import ProcessingStatus


class StageExecutor(ABC):
    """
    階段執行器基類 - 統一執行流程

    使用 Template Method Pattern，定義標準執行流程：
    1. 顯示階段頭部
    2. 清理舊輸出
    3. 載入前階段數據（如需要）
    4. 載入配置（子類實現）
    5. 創建處理器（子類實現）
    6. 執行處理
    7. 保存驗證快照
    8. 錯誤處理

    子類只需實現:
    - load_config(): 載入階段配置
    - create_processor(): 創建處理器實例
    - requires_previous_stage(): 是否需要前階段數據（可選）
    """

    def __init__(self, stage_number: int, stage_name: str, emoji: str = "📦"):
        """
        初始化執行器

        Args:
            stage_number: 階段編號 (1-6)
            stage_name: 階段名稱（中文）
            emoji: 階段圖標（可選，默認 📦）
        """
        self.stage_number = stage_number
        self.stage_name = stage_name
        self.emoji = emoji
        self.logger = logging.getLogger(f"stage{stage_number}_executor")

    def execute(self, previous_results: Optional[Dict] = None) -> Tuple[bool, Any, Any]:
        """
        執行階段處理（模板方法）

        這是核心執行流程，子類不應覆蓋此方法。
        子類應實現 load_config() 和 create_processor()。

        Args:
            previous_results: 前序階段結果字典（可選）

        Returns:
            tuple: (success: bool, result: ProcessingResult, processor: Processor)
                - success: 是否執行成功
                - result: 處理結果對象（或 None）
                - processor: 處理器實例（或 None）
        """
        try:
            # Step 1: 顯示階段頭部
            self._print_stage_header()

            # Step 2: 清理舊輸出
            clean_stage_outputs(self.stage_number)

            # Step 3: 載入前階段數據（如需要）
            input_data = None
            if self.requires_previous_stage():
                input_data = self._load_previous_stage_data()
                if input_data is None:
                    # 前階段數據缺失，無法繼續
                    return False, None, None

            # Step 4: 載入配置（子類實現）
            config = self.load_config()

            # Step 5: 顯示配置摘要（可選）
            self._print_config_summary(config)

            # Step 6: 創建處理器（子類實現）
            processor = self.create_processor(config)

            # Step 7: 執行處理（統一接口）
            result = processor.execute(input_data)

            # Step 8: 檢查結果
            if not self._check_result(result):
                return False, result, processor

            # Step 9: 顯示處理結果摘要
            self._print_result_summary(result)

            # Step 10: 保存驗證快照（如果處理器支持）
            self._save_validation_snapshot(processor, result)

            return True, result, processor

        except Exception as e:
            # 統一錯誤處理
            error_msg = f'❌ Stage {self.stage_number} 執行異常: {e}'
            self.logger.error(error_msg, exc_info=True)
            print(error_msg)
            return False, None, None

    # ===== 子類必須實現的抽象方法 =====

    @abstractmethod
    def load_config(self) -> Dict[str, Any]:
        """
        載入階段配置

        子類必須實現此方法，從 YAML 文件或其他來源載入配置。

        Returns:
            Dict[str, Any]: 配置字典

        Example:
            ```python
            def load_config(self) -> Dict[str, Any]:
                config_path = project_root / "config/stage1_orbital_calculation.yaml"
                with open(config_path, 'r') as f:
                    return yaml.safe_load(f)
            ```
        """
        pass

    @abstractmethod
    def create_processor(self, config: Dict[str, Any]) -> Any:
        """
        創建處理器實例

        子類必須實現此方法，根據配置創建對應的處理器。

        Args:
            config: load_config() 返回的配置字典

        Returns:
            處理器實例（繼承自 BaseStageProcessor）

        Example:
            ```python
            def create_processor(self, config):
                from stages.stage1_orbital_calculation.stage1_main_processor import create_stage1_processor
                return create_stage1_processor(config)
            ```
        """
        pass

    # ===== 子類可覆蓋的可選方法 =====

    def requires_previous_stage(self) -> bool:
        """
        是否需要前階段數據

        默認行為：Stage 1 不需要，其他階段需要。
        子類可以覆蓋此方法自定義行為。

        Returns:
            bool: True 如果需要前階段數據
        """
        return self.stage_number > 1

    def get_previous_stage_number(self) -> int:
        """
        獲取前階段編號

        默認行為：當前階段 - 1
        子類可以覆蓋此方法（例如跳階段執行）。

        Returns:
            int: 前階段編號
        """
        return self.stage_number - 1

    # ===== 內部輔助方法（基類實現，子類不應覆蓋） =====

    def _print_stage_header(self):
        """顯示階段頭部信息"""
        print(f'\n{self.emoji} 階段{self.stage_number}：{self.stage_name}')
        print('-' * 60)

    def _load_previous_stage_data(self) -> Optional[Dict]:
        """
        載入前階段數據

        Returns:
            Optional[Dict]: 前階段數據，如果找不到則返回 None
        """
        previous_stage = self.get_previous_stage_number()
        output_file = find_latest_stage_output(previous_stage)

        if not output_file:
            error_msg = f'❌ 找不到 Stage {previous_stage} 輸出文件，請先執行 Stage {previous_stage}'
            self.logger.error(error_msg)
            print(error_msg)
            return None

        try:
            with open(output_file, 'r', encoding='utf-8') as f:
                data = json.load(f)
            self.logger.info(f"✅ 已載入 Stage {previous_stage} 數據: {output_file}")
            return data
        except Exception as e:
            error_msg = f'❌ 載入 Stage {previous_stage} 數據失敗: {e}'
            self.logger.error(error_msg)
            print(error_msg)
            return None

    def _check_result(self, result) -> bool:
        """
        檢查處理結果

        Args:
            result: 處理器返回的結果

        Returns:
            bool: True 如果結果有效
        """
        if not result:
            error_msg = f'❌ Stage {self.stage_number} 無返回結果'
            self.logger.error(error_msg)
            print(error_msg)
            return False

        # 調試：顯示 result 的類型和狀態
        self.logger.debug(f"🔍 Result type: {type(result)}")
        self.logger.debug(f"🔍 Has status: {hasattr(result, 'status')}")
        if hasattr(result, 'status'):
            self.logger.debug(f"🔍 Status value: {result.status}")
            self.logger.debug(f"🔍 Status type: {type(result.status)}")
            self.logger.debug(f"🔍 ProcessingStatus.SUCCESS: {ProcessingStatus.SUCCESS}")
            self.logger.debug(f"🔍 Comparison: {result.status == ProcessingStatus.SUCCESS}")

        # 檢查狀態
        if hasattr(result, 'status'):
            # 支持枚舉和字符串比較（向後兼容）
            is_success = (result.status == ProcessingStatus.SUCCESS or
                         result.status == ProcessingStatus.COMPLETED or
                         (hasattr(result.status, 'value') and result.status.value == 'success'))

            if not is_success:
                errors = '; '.join(result.errors) if hasattr(result, 'errors') and result.errors else "未知錯誤"
                error_msg = f'❌ Stage {self.stage_number} 執行失敗: {errors}'
                self.logger.error(error_msg)
                print(error_msg)
                return False

        # 檢查數據
        if hasattr(result, 'data') and not result.data:
            error_msg = f'❌ Stage {self.stage_number} 返回數據為空'
            self.logger.error(error_msg)
            print(error_msg)
            return False

        return True

    def _save_validation_snapshot(self, processor, result):
        """
        保存驗證快照

        Args:
            processor: 處理器實例
            result: 處理結果
        """
        if not hasattr(processor, 'save_validation_snapshot'):
            # 處理器不支持快照保存，跳過
            return

        try:
            # 提取數據（處理 ProcessingResult 對象）
            data = result.data if hasattr(result, 'data') else result

            # 調用處理器的快照保存方法
            snapshot_saved = processor.save_validation_snapshot(data)

            if snapshot_saved:
                self.logger.info(f'✅ Stage {self.stage_number} 驗證快照已保存')
                print(f'✅ Stage {self.stage_number} 驗證快照已保存')
            else:
                self.logger.warning(f'⚠️ Stage {self.stage_number} 驗證快照保存失敗')
                print(f'⚠️ Stage {self.stage_number} 驗證快照保存失敗')

        except Exception as e:
            # 快照保存失敗不應中斷主流程，只記錄警告
            warning_msg = f'⚠️ Stage {self.stage_number} 驗證快照保存失敗: {e}'
            self.logger.warning(warning_msg)
            print(warning_msg)

    def _print_config_summary(self, config: Dict[str, Any]):
        """
        顯示配置摘要（可選，由子類決定是否調用）

        Args:
            config: 配置字典
        """
        # 基類不顯示，子類可以覆蓋此方法添加自定義摘要
        pass

    def _print_result_summary(self, result):
        """
        顯示處理結果摘要

        Args:
            result: 處理結果
        """
        if not hasattr(result, 'data') or not hasattr(result, 'metrics'):
            return

        data = result.data
        metrics = result.metrics

        # 顯示通用統計信息
        print(f'📊 處理狀態: {result.status.value if hasattr(result, "status") else "未知"}')

        if hasattr(metrics, 'duration_seconds'):
            print(f'📊 處理時間: {metrics.duration_seconds:.3f}秒')

        # 顯示階段特定的統計（如果有）
        if isinstance(data, dict):
            # Stage 1: 衛星數量
            if 'satellites' in data:
                print(f'📊 處理衛星: {len(data["satellites"])}顆')

            # Stage 2: 時間序列長度
            if 'metadata' in data and 'time_series_length' in data['metadata']:
                print(f'📊 時間序列: {data["metadata"]["time_series_length"]}點')

            # Stage 4: 可見衛星數量
            if 'link_feasibility' in data:
                print(f'📊 可見衛星: {len(data["link_feasibility"])}顆')

            # Stage 5: 信號分析衛星數量
            if 'signal_analysis' in data:
                print(f'📊 分析衛星: {len(data["signal_analysis"])}顆')

            # Stage 6: 事件數量
            if 'handover_events' in data:
                print(f'📊 換手事件: {len(data["handover_events"])}個')


# ===== 便捷函數（向後兼容） =====

def create_stage_executor(stage_number: int, executor_class) -> StageExecutor:
    """
    創建階段執行器的工廠函數

    Args:
        stage_number: 階段編號
        executor_class: 執行器類

    Returns:
        StageExecutor: 執行器實例
    """
    return executor_class()
