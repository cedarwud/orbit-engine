"""
Stage 2 åŸ·è¡Œå™¨ - è»Œé“ç‹€æ…‹å‚³æ’­å±¤

é‡æ§‹ç‰ˆæœ¬ï¼šä½¿ç”¨ StageExecutor åŸºé¡ + Stage2ConfigManager

Author: Orbit Engine Refactoring Team
Date: 2025-10-12
Version: 3.0 (Phase 4 P1 - Configuration Management)
"""

from typing import Dict, Any
from pathlib import Path

from .base_executor import StageExecutor
from .executor_utils import project_root


class Stage2Executor(StageExecutor):
    """
    Stage 2 åŸ·è¡Œå™¨ - è»Œé“ç‹€æ…‹å‚³æ’­å±¤ (v3.0)

    ç¹¼æ‰¿è‡ª StageExecutorï¼Œåªéœ€å¯¦ç¾é…ç½®åŠ è¼‰å’Œè™•ç†å™¨å‰µå»ºé‚è¼¯ã€‚
    """

    def __init__(self):
        super().__init__(
            stage_number=2,
            stage_name="è»Œé“ç‹€æ…‹å‚³æ’­å±¤ (v3.0 é‡æ§‹ç‰ˆæœ¬)",
            emoji="ğŸ›°ï¸"
        )

    def load_config(self) -> Dict[str, Any]:
        """
        è¼‰å…¥ Stage 2 é…ç½®

        ä½¿ç”¨ Stage2ConfigManager åŠ è¼‰é…ç½®ï¼Œæ”¯æŒ:
        - YAML é…ç½®æ–‡ä»¶
        - ç’°å¢ƒè®Šæ•¸è¦†å¯«ï¼ˆflat + nested keysï¼‰
        - Fail-Fast é©—è­‰
        - å‘å¾Œå…¼å®¹èˆŠé…ç½®æ–‡ä»¶åç¨±

        Returns:
            Dict[str, Any]: é…ç½®å­—å…¸
        """
        # å°å…¥ Stage2ConfigManager
        try:
            from stages.stage2_orbital_computing.stage2_config_manager import Stage2ConfigManager
        except ImportError:
            import sys
            sys.path.insert(0, str(project_root / 'src'))
            from stages.stage2_orbital_computing.stage2_config_manager import Stage2ConfigManager

        config_manager = Stage2ConfigManager()

        # æª¢æŸ¥é…ç½®æ–‡ä»¶ï¼ˆå„ªå…ˆä½¿ç”¨æ–°å‘½åï¼‰
        new_config_path = project_root / "config/stage2_orbital_computing_config.yaml"
        old_config_path = project_root / "config/stage2_orbital_computing.yaml"

        if new_config_path.exists():
            config_dict = config_manager.load_config(custom_path=new_config_path)
            print(f"âœ… å·²è¼‰å…¥ Stage 2 é…ç½®: {new_config_path}")
        elif old_config_path.exists():
            config_dict = config_manager.load_config(custom_path=old_config_path)
            print(f"âœ… å·²è¼‰å…¥ Stage 2 é…ç½®: {old_config_path}")
            print(f"âš ï¸  å»ºè­°é·ç§»è‡³æ–°é…ç½®æ–‡ä»¶åç¨±: {new_config_path.name}")
        else:
            config_dict = config_manager.load_config()
            print("âš ï¸ æœªæ‰¾åˆ°é…ç½®æ–‡ä»¶ï¼Œä½¿ç”¨é è¨­é…ç½®")

        # é¡¯ç¤ºé…ç½®æ‘˜è¦
        time_config = config_dict.get('time_series', {})
        sgp4_config = config_dict.get('sgp4_propagation', {})
        performance_config = config_dict.get('performance', {})

        print(f"ğŸ“‹ é…ç½®æ‘˜è¦:")
        print(f"   æ™‚é–“åºåˆ—æ¨¡å¼: {time_config.get('mode', 'N/A')}")
        print(f"   æ™‚é–“é–“éš”: {time_config.get('interval_seconds', 'N/A')}ç§’")
        print(f"   è¦†è“‹é€±æœŸ: {time_config.get('coverage_cycles', 'N/A')}x")
        print(f"   åº§æ¨™ç³»çµ±: {sgp4_config.get('output_coordinate_system', 'TEME')}")
        print(f"   SGP4 æ–¹æ³•: {sgp4_config.get('method', 'SGP4')}")

        max_workers = performance_config.get('max_workers')
        if max_workers:
            print(f"   ä¸¦è¡Œå·¥ä½œå™¨: {max_workers} å€‹")
        else:
            print(f"   ä¸¦è¡Œå·¥ä½œå™¨: å‹•æ…‹è¨ˆç®—")

        return config_dict

    def create_processor(self, config: Dict[str, Any]):
        """
        å‰µå»º Stage 2 è™•ç†å™¨

        Args:
            config: load_config() è¿”å›çš„é…ç½®å­—å…¸

        Returns:
            Stage2OrbitalPropagationProcessor: è™•ç†å™¨å¯¦ä¾‹
        """
        from stages.stage2_orbital_computing.stage2_orbital_computing_processor import Stage2OrbitalPropagationProcessor
        return Stage2OrbitalPropagationProcessor(config=config)


# ===== å‘å¾Œå…¼å®¹å‡½æ•¸ =====

def execute_stage2(previous_results=None):
    """
    åŸ·è¡Œ Stage 2: è»Œé“ç‹€æ…‹å‚³æ’­å±¤ (v3.0)

    å‘å¾Œå…¼å®¹å‡½æ•¸ï¼Œä¿æŒåŸæœ‰èª¿ç”¨æ–¹å¼ã€‚
    å…§éƒ¨ä½¿ç”¨ Stage2Executor é¡å¯¦ç¾ã€‚

    Args:
        previous_results: å‰åºéšæ®µçµæœå­—å…¸ï¼ˆå¿…é ˆåŒ…å« 'stage1' çµæœï¼‰

    Returns:
        tuple: (success: bool, result: ProcessingResult, processor: Stage2Processor)
    """
    executor = Stage2Executor()
    return executor.execute(previous_results)
