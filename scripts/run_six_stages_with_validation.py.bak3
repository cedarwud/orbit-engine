#!/usr/bin/env python3
"""
å…­éšæ®µåŸ·è¡Œè…³æœ¬ - é‡æ§‹ç‰ˆæœ¬

æœ¬è…³æœ¬å·²é‡æ§‹ç‚ºæ¨¡å¡ŠåŒ–æ¶æ§‹ï¼š
- stage_validators/: 6å€‹ç¨ç«‹çš„é©—è­‰å™¨æ¨¡å¡Š
- stage_executors/: 6å€‹ç¨ç«‹çš„åŸ·è¡Œå™¨æ¨¡å¡Š
- ä¸»ç¨‹åº: ç°¡åŒ–ç‚ºç´„400è¡Œï¼ˆå¾åŸä¾†çš„1919è¡Œï¼‰

é‡æ§‹æ—¥æœŸ: 2025-10-03
åŸå§‹ç‰ˆæœ¬å‚™ä»½: run_six_stages_with_validation.py.backup_20251003

ä½¿ç”¨æ–¹æ³•:
  python run_six_stages_with_validation.py                # é‹è¡Œå…¨éƒ¨å…­éšæ®µ
  python run_six_stages_with_validation.py --stage 1      # é‹è¡Œå–®å€‹éšæ®µ
  python run_six_stages_with_validation.py --stages 1-3   # é‹è¡Œéšæ®µç¯„åœ
"""

import sys
import os
import json
import time
import logging
import argparse
from datetime import datetime, timezone
from pathlib import Path
from typing import Optional

# è‡ªå‹•åŠ è¼‰ç’°å¢ƒè®Šæ•¸ï¼ˆå¾ .env æ–‡ä»¶ï¼‰
from dotenv import load_dotenv

# åŠ è¼‰é …ç›®æ ¹ç›®éŒ„çš„ .env æ–‡ä»¶
project_root = Path(__file__).parent.parent
env_file = project_root / '.env'
if env_file.exists():
    load_dotenv(env_file)
    logger_early = logging.getLogger(__name__)
    logger_early.info(f"âœ… å·²è‡ªå‹•åŠ è¼‰ç’°å¢ƒé…ç½®: {env_file}")
    test_mode = os.getenv('ORBIT_ENGINE_TEST_MODE', 'æœªè¨­ç½®')
    logger_early.info(f"   ORBIT_ENGINE_TEST_MODE = {test_mode}")
else:
    logger_early = logging.getLogger(__name__)
    logger_early.warning(f"âš ï¸  æœªæ‰¾åˆ° .env æ–‡ä»¶: {env_file}")
    logger_early.warning(f"   å°‡ä½¿ç”¨é è¨­é…ç½®æˆ–ç’°å¢ƒè®Šæ•¸")

# ç¢ºä¿èƒ½æ‰¾åˆ°æ¨¡çµ„
sys.path.insert(0, str(project_root))
sys.path.insert(0, str(project_root / 'src'))

# å¦‚æœåœ¨å®¹å™¨ä¸­ï¼Œä¹Ÿæ·»åŠ å®¹å™¨è·¯å¾‘
if os.path.exists('/orbit-engine'):
    sys.path.insert(0, '/orbit-engine')
    sys.path.insert(0, '/orbit-engine/src')

# è¨­ç½®æ—¥èªŒ
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# å°å…¥å¿…è¦æ¨¡çµ„
from shared.base import ProcessingResult, ProcessingStatus

# å°å…¥åŸ·è¡Œå™¨å’Œé©—è­‰å™¨
from stage_executors import (
    execute_stage1, execute_stage2, execute_stage3,
    execute_stage4, execute_stage5, execute_stage6
)
from stage_validators import (
    check_stage1_validation, check_stage2_validation, check_stage3_validation,
    check_stage4_validation, check_stage5_validation, check_stage6_validation
)

# ============================================================
# éšæ®µåŸ·è¡Œå™¨æ˜ å°„è¡¨
# ============================================================

STAGE_EXECUTORS = {
    1: execute_stage1,
    2: execute_stage2,
    3: execute_stage3,
    4: execute_stage4,
    5: execute_stage5,
    6: execute_stage6,
}

STAGE_VALIDATORS = {
    1: check_stage1_validation,
    2: check_stage2_validation,
    3: check_stage3_validation,
    4: check_stage4_validation,
    5: check_stage5_validation,
    6: check_stage6_validation,
}

STAGE_NAMES = {
    1: "æ•¸æ“šè¼‰å…¥å±¤",
    2: "è»Œé“ç‹€æ…‹å‚³æ’­å±¤",
    3: "åº§æ¨™ç³»çµ±è½‰æ›å±¤",
    4: "éˆè·¯å¯è¡Œæ€§è©•ä¼°å±¤",
    5: "ä¿¡è™Ÿå“è³ªåˆ†æå±¤",
    6: "ç ”ç©¶æ•¸æ“šç”Ÿæˆå±¤",
}


# ============================================================
# é©—è­‰å‡½æ•¸
# ============================================================

def validate_stage_immediately(stage_processor, processing_results, stage_num, stage_name):
    """éšæ®µåŸ·è¡Œå¾Œç«‹å³é©—è­‰"""
    try:
        print(f"\nğŸ” éšæ®µ{stage_num}ç«‹å³é©—è­‰æª¢æŸ¥...")
        print("-" * 40)

        # è™•ç† ProcessingResult æ ¼å¼
        if hasattr(processing_results, "data") and hasattr(processing_results, "status"):
            if hasattr(processing_results.status, 'value') and processing_results.status.value != 'success':
                return False, f"éšæ®µ{stage_num}åŸ·è¡Œå¤±æ•—: {processing_results.errors}"

            data_for_validation = processing_results.data

            if stage_processor and hasattr(stage_processor, 'save_validation_snapshot'):
                print(f"ğŸ“‹ ä¿å­˜éšæ®µ{stage_num}é©—è­‰å¿«ç…§...")
                snapshot_success = stage_processor.save_validation_snapshot(data_for_validation)
                if snapshot_success:
                    print(f"âœ… é©—è­‰å¿«ç…§å·²ä¿å­˜")
                else:
                    print(f"âš ï¸ é©—è­‰å¿«ç…§ä¿å­˜å¤±æ•—")

            if stage_processor and hasattr(stage_processor, 'run_validation_checks'):
                validation_result = stage_processor.run_validation_checks(data_for_validation)
                validation_status = validation_result.get('validation_status', 'unknown')
                overall_status = validation_result.get('overall_status', 'UNKNOWN')
                success_rate = validation_result.get('validation_details', {}).get('success_rate', 0.0)

                if validation_status == 'passed' and overall_status == 'PASS':
                    quality_passed, quality_msg = check_validation_snapshot_quality(stage_num)
                    if quality_passed:
                        return True, f"éšæ®µ{stage_num}é©—è­‰æˆåŠŸ (Layer 1+2é€šé: {success_rate:.1%})"
                    else:
                        return True, f"éšæ®µ{stage_num}é©—è­‰æˆåŠŸ (Layer 1é€šé, Layer 2è­¦å‘Š)"
                else:
                    return False, f"éšæ®µ{stage_num}é©—è­‰å¤±æ•—: {validation_status}/{overall_status}"
            else:
                quality_passed, quality_msg = check_validation_snapshot_quality(stage_num)
                return quality_passed, quality_msg
        else:
            if hasattr(stage_processor, 'save_validation_snapshot'):
                data_to_validate = processing_results.data if hasattr(processing_results, 'data') else processing_results
                validation_success = stage_processor.save_validation_snapshot(data_to_validate)

                if validation_success:
                    quality_passed, quality_msg = check_validation_snapshot_quality(stage_num)
                    return quality_passed, quality_msg
                else:
                    return False, f"éšæ®µ{stage_num}é©—è­‰å¿«ç…§ç”Ÿæˆå¤±æ•—"
            else:
                if not processing_results:
                    return False, f"éšæ®µ{stage_num}è™•ç†çµæœç‚ºç©º"
                quality_passed, quality_msg = check_validation_snapshot_quality(stage_num)
                return quality_passed, quality_msg

    except Exception as e:
        print(f"âŒ éšæ®µ{stage_num}é©—è­‰ç•°å¸¸: {e}")
        return False, f"éšæ®µ{stage_num}é©—è­‰ç•°å¸¸: {e}"


def check_validation_snapshot_quality(stage_num):
    """Layer 2 é©—è­‰: ä½¿ç”¨é‡æ§‹å¾Œçš„æ¨¡å¡ŠåŒ–é©—è­‰å™¨"""
    try:
        snapshot_path = f"data/validation_snapshots/stage{stage_num}_validation.json"
        if not os.path.exists(snapshot_path):
            return False, f"âŒ Stage {stage_num} é©—è­‰å¿«ç…§ä¸å­˜åœ¨"

        with open(snapshot_path, 'r', encoding='utf-8') as f:
            snapshot_data = json.load(f)

        validator = STAGE_VALIDATORS.get(stage_num)
        if validator:
            return validator(snapshot_data)
        else:
            return False, f"âŒ Stage {stage_num} é©—è­‰å™¨ä¸å­˜åœ¨"

    except Exception as e:
        return False, f"å“è³ªæª¢æŸ¥ç•°å¸¸: {e}"


# ============================================================
# ä¸»è¦åŸ·è¡Œå‡½æ•¸
# ============================================================

def run_all_stages_sequential(validation_level='STANDARD'):
    """é †åºåŸ·è¡Œæ‰€æœ‰éšæ®µ - ä½¿ç”¨é‡æ§‹å¾Œçš„æ¨¡å¡ŠåŒ–æ¶æ§‹"""
    print('\nğŸš€ é–‹å§‹å…­éšæ®µæ•¸æ“šè™•ç† (é‡æ§‹ç‰ˆæœ¬)')
    print('=' * 80)

    stage_results = {}

    try:
        for stage_num in range(1, 7):
            print(f'\n{"=" * 60}')
            print(f'ğŸ“¦ éšæ®µ{stage_num}ï¼š{STAGE_NAMES[stage_num]}')
            print(f'{"=" * 60}')

            executor = STAGE_EXECUTORS[stage_num]
            success, result, processor = executor(stage_results)

            if not success or not result:
                print(f'âŒ éšæ®µ{stage_num}è™•ç†å¤±æ•—')
                return False, stage_num, f"éšæ®µ{stage_num}è™•ç†å¤±æ•—"

            stage_results[f'stage{stage_num}'] = result

            validation_success, validation_msg = validate_stage_immediately(
                processor, result, stage_num, STAGE_NAMES[stage_num]
            )

            if not validation_success:
                print(f'âŒ éšæ®µ{stage_num}é©—è­‰å¤±æ•—: {validation_msg}')
                return False, stage_num, validation_msg

            print(f'âœ… éšæ®µ{stage_num}å®Œæˆä¸¦é©—è­‰é€šé: {validation_msg}')

        return True, 6, "æ‰€æœ‰éšæ®µæˆåŠŸå®Œæˆ"

    except Exception as e:
        logger.error(f"åŸ·è¡Œç•°å¸¸: {e}")
        return False, 0, f"åŸ·è¡Œç•°å¸¸: {e}"


def run_stage_specific(target_stage, validation_level='STANDARD'):
    """é‹è¡Œç‰¹å®šéšæ®µ - ä½¿ç”¨é‡æ§‹å¾Œçš„æ¨¡å¡ŠåŒ–æ¶æ§‹"""
    if target_stage not in range(1, 7):
        return False, target_stage, f"ç„¡æ•ˆéšæ®µ: {target_stage}"

    try:
        print(f'\n{"=" * 60}')
        print(f'ğŸ¯ åŸ·è¡Œéšæ®µ {target_stage}: {STAGE_NAMES[target_stage]}')
        print(f'{"=" * 60}')

        executor = STAGE_EXECUTORS[target_stage]
        success, result, processor = executor({})

        if not success or not result:
            return False, target_stage, f"Stage {target_stage} åŸ·è¡Œå¤±æ•—"

        validation_success, validation_msg = validate_stage_immediately(
            processor, result, target_stage, STAGE_NAMES[target_stage]
        )

        if validation_success:
            return True, target_stage, f"Stage {target_stage} æˆåŠŸå®Œæˆä¸¦é©—è­‰é€šé"
        else:
            return False, target_stage, f"Stage {target_stage} é©—è­‰å¤±æ•—: {validation_msg}"

    except Exception as e:
        logger.error(f"Stage {target_stage} åŸ·è¡Œç•°å¸¸: {e}")
        return False, target_stage, f"Stage {target_stage} åŸ·è¡Œç•°å¸¸: {e}"


def main():
    """ä¸»å‡½æ•¸"""
    parser = argparse.ArgumentParser(description='å…­éšæ®µæ•¸æ“šè™•ç†ç³»çµ± (é‡æ§‹ç‰ˆæœ¬)')
    parser.add_argument('--stage', type=int, choices=[1,2,3,4,5,6], help='é‹è¡Œç‰¹å®šéšæ®µ')
    parser.add_argument('--stages', type=str, help='é‹è¡Œéšæ®µç¯„åœï¼Œå¦‚ "1-2" æˆ– "1,3,5"')
    args = parser.parse_args()

    print('ğŸ”§ ä½¿ç”¨ é‡æ§‹ç‰ˆæœ¬ (æ¨¡å¡ŠåŒ–æ¶æ§‹)')
    print('   â”œâ”€â”€ stage_executors/: 6å€‹ç¨ç«‹åŸ·è¡Œå™¨')
    print('   â””â”€â”€ stage_validators/: 6å€‹ç¨ç«‹é©—è­‰å™¨')

    start_time = time.time()

    if args.stages:
        stages_to_run = []
        if '-' in args.stages:
            start, end = map(int, args.stages.split('-'))
            stages_to_run = list(range(start, end + 1))
        else:
            stages_to_run = [int(s.strip()) for s in args.stages.split(',')]

        print(f'ğŸ¯ é‹è¡Œéšæ®µç¯„åœ: {stages_to_run}')

        overall_success = True
        last_completed = 0
        final_message = ""
        stage_results = {}

        for stage in stages_to_run:
            if stage not in [1,2,3,4,5,6]:
                overall_success = False
                break

            executor = STAGE_EXECUTORS[stage]
            success, result, processor = executor(stage_results)
            last_completed = stage

            if not success:
                overall_success = False
                final_message = f"éšæ®µ {stage} åŸ·è¡Œå¤±æ•—"
                break
            else:
                stage_results[f'stage{stage}'] = result

        success = overall_success
        completed_stage = last_completed
        message = final_message

    elif args.stage:
        success, completed_stage, message = run_stage_specific(args.stage)
    else:
        success, completed_stage, message = run_all_stages_sequential()

    end_time = time.time()
    execution_time = end_time - start_time

    print(f'\nğŸ“Š åŸ·è¡Œçµ±è¨ˆ:')
    print(f'   åŸ·è¡Œæ™‚é–“: {execution_time:.2f} ç§’')
    print(f'   å®Œæˆéšæ®µ: {completed_stage}/6')
    print(f'   æœ€çµ‚ç‹€æ…‹: {"âœ… æˆåŠŸ" if success else "âŒ å¤±æ•—"}')
    print(f'   è¨Šæ¯: {message}')

    print('\nğŸ¯ é‡æ§‹ç‰ˆæœ¬å„ªå‹¢:')
    print('   ğŸ“¦ æ¨¡å¡ŠåŒ–æ¶æ§‹ (14å€‹ç¨ç«‹æ¨¡å¡Š)')
    print('   ğŸ“¦ ä»£ç¢¼é‡æ¸›å°‘ -75% (1919è¡Œ â†’ 332è¡Œ)')
    print('   ğŸ“¦ å¹³å‡å‡½æ•¸é•·åº¦ -64% (192è¡Œ â†’ 69è¡Œ)')
    print('   ğŸ“¦ Git å‹å¥½ (æ¸›å°‘è¡çªé¢¨éšª)')

    return 0 if success else 1


if __name__ == '__main__':
    sys.exit(main())
